[转载：https://blog.csdn.net/weixin_39818813?type=lately](https://blog.csdn.net/weixin_39818813?type=lately)

前端知识体系3：【webpack+http】
## 6. webpack

### 9.1. webpack的4要点（entry、output、loader、plugins）
【网易】

[详情>](https://segmentfault.com/a/1190000021494964)

### 9.2 webpack loader 和 plugin 的区别

### 9.2 webpack import 打包后的结果是怎样的？
【字节】

> `import`经过`webpack`打包以后变成一些`Map`对象，`key`为模块路径，`value`为模块的可执行函数；

> 代码加载到浏览器以后从入口模块开始执行，其中执行的过程中，最重要的就是`webpack`定义的`__webpack_require__`函数，负责实际的模块加载并执行这些模块内容，返回执行结果，其实就是读取`Map`对象，然后执行相应的函数；

> 当然其中的异步方法（import('xxModule')）比较特殊一些，它会单独打成一个包，采用动态加载的方式，具体过程：当用户触发其加载的动作时，会动态的在`head`标签中创建一个`script`标签，然后发送一个`http`请求，加载模块，模块加载完成以后自动执行其中的代码，主要的工作有两个，更改缓存中模块的状态，另一个就是执行模块代码。

[详情>](https://juejin.cn/post/6859569958742196237)

### 9.1.babel如何编译【必背】

![image.png](https://img-blog.csdnimg.cn/img_convert/4e0ee7117be87f110b7c406021250ea1.png)

[详情1》](https://juejin.cn/post/6844903956905197576)

[详情2》](https://juejin.cn/post/6844903746804137991)


### 9.1 webpack怎么加载的？【必背】
【网易游戏，字节】

*`webpack`的打包过程大概流程是这样的：*

> -   合并`webpack.config.js`和命令行传递的参数，形成最终的配置
> -   解析配置，得到`entry`入口
> -   读取入口文件内容，通过`@babel/parse`将入口内容（code）转换成`ast`
> -   通过`@babel/traverse`遍历`ast`得到模块的各个依赖
> -   通过`@babel/core`（实际的转换工作是由`@babel/preset-env`来完成的）将`ast`转换成`es5 code`
> -   通过循环伪递归的方式拿到所有模块的所有依赖并都转换成`es5`


[webpack的打包构建流程](https://segmentfault.com/a/1190000021494964)(写的很明白可以多看几遍，看完几乎可以自己写一个简易的webpack了)

[深入浅出 Webpack手册---文档>](https://webpack.wuhaolin.cn/)

### 9.2 webpack 异步加载和分包的原理是什么

【腾讯】

webpack的分包如何实现？可以说下具体的配置吗？

[异步加载和分包](https://www.cnblogs.com/goloving/p/14030945.html)



### 9.3 webpack 打 polyfill 都有哪几种方式

【腾讯】

[link](https://segmentfault.com/a/1190000010106158)

### 9.1 webpack和vite的区别

webpack构建的时候需要全量构建，在浏览器渲染前就需要从入口文件开始，将所有路由文件的依赖以及依赖的依赖全部打包，放入js bundle中，然后再启动开发服务器，所以耗时会很久。

而vite先启动开发服务器，利用了浏览器ESMoudule能力,无需打包，直接在请求所需模块并实时编译，

Webpack       | Vite   |
| -------------------- | --------------------------------------------------- |
| 先打包生成bundle，再启动开发服务器        | 先启动开发服务器，利用新一代浏览器的ESM能力，无需打包，直接请求所需模块并实时编译          |
| HMR时需要把改动模块及相关依赖全部编译 | HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求

### 9.1 介绍一下 vite 的原理，它会去编译你的代码吗，vite 引用 commonjs 的包的时候怎么处理

【小红书】

Vite 会在本地帮你启动一个服务器，当浏览器读取到 html 文件之后，会在执行到 import 的时候才去向服务端发送 某个模块的请求，Vite 此时在利用内部的一系列黑魔法，包括 Vue 的 template 解析，代码的编译等等，解析成浏览器可以执行的 js 文件返回到浏览器端。

这就保证了只有在真正使用到这个模块的时候，浏览器才会请求并且解析这个模块，最大程度的做到了按需加载。

换个支持vite的包吧

[原理](https://juejin.cn/post/6932367804108800007#heading-1)

### 9.2 为什么Vite比webpack快很多，ESM和commonJS的区别是什么，为什么ESM加载会更快，如何理解ESM的静态
【大疆】

### 9.2 Vite 依赖与预构建是把所有的用到的依赖都合并到一起还是每个都是单独的包，一个包安装了多个版本问题如何处理

[预构建](https://juejin.cn/post/6932367804108800007#heading-2)


### 9.2 webpack 迁移 Vite 遇到过哪些问题，之前 webpack 慢是为什么，有过优化么，迁移后怎么测试的

【小红书，美团，腾讯音乐】

查看自己写的webpack迁移的文章

**webpack 慢**

因为它需要全量构建

**优化**

查看webpack性能优化

### 9.2 webpack 和 vite 的区别是什么，切 Vite 的动力是什么
【网易灵犀】

[vite介绍](https://juejin.cn/post/6980141344131923999)

一方面我们的项目启动每次都要40s以上，另外一方面也是想了解下新的技术。

### 9.2 snowpack 有了解过么，它和 vite 有什么区别
【网易灵犀】

snowpack 以 ES Modules 为主

[link](https://blog.csdn.net/NewTyun/article/details/118004978)

### 9.3 Rollup和webpack打包结果有什么异同
【腾讯广告】

### 9.2  微前端有了解吗

**什么是微前端**

`微前端`是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由`单一`的单体应用转变为`多个小型前端应用`聚合为一的应用。各个前端应用还可以`独立运行`、`独立开发`、`独立部署`。

**什么要用微前端**

任何一种技术或者概念都有其适用场景，微前端也不例外。 针对中小型的项目，使用微前端反而会将事情复杂化 ，因为微前端对项目的开发并不友好。

适用于以下场景：

- 项目技术栈过于老旧,相关技能的开发人员少,功能扩展吃力,重构成本高,维护成本高.
- 项目过于庞大,代码编译慢,开发体差,需要一种更高维度的解耦方案.
- 单一技术栈无法满足你的业务需求

**使用过哪个方案**

有使用过webpack5的联邦模块对现有的2个项目进行构建

[link](https://wanglaibin.blog.csdn.net/article/details/100527780?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link)

### 9.3 你有了解过 webpack 现在也支持 esm 了吗？

webpack4需要通过插件esm-webpack-plugin才能实现。webpack5直接支持。

### 9.4 前端的工程化都做了哪些事情？
【美团，网易传媒，腾讯，360】
    
**前端工程化**是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的***为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间***，而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。

前端工程化就是为了让前端开发能够“自成体系”，主要包括**模块化**、**组件化**、**规范化**、**自动化**四个方面

- 模块化: 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。
- 组件化：组件化是在`设计层面`上，对UI（用户界面）的拆分。（模块化只是在`文件层面`上，对代码或资源的拆分；）
- 规范化：目录结构的制定，编码规范，HTML规范，CSS规范，图片规范，命名规范，前后端接口规范。
- 自动化：自动化构建，自动化测试，自动化部署

[详情](https://www.jianshu.com/p/88ed70476adb)

### 9.5 esbuild 有了解吗
【知乎】

了解不多，只知道ESbuild 是一个类似webpack构建工具。它的构建速度是 webpack 的几十倍。

**为什么这么快 ？**

- js是单线程串行，esbuild是新开一个进程，然后多线程并行，充分发挥多核优势
- go是纯机器码，肯定要比JIT快
- 不使用 AST，优化了构建流程。（也带来了一些缺点，后面会说）

[详情](https://juejin.cn/post/6918927987056312327)

### 9.6 写过webpack插件么
【网易传媒,360】

### 9.7  babel转换的原理是什么
【网易传媒】

### 9.8 babel配置过么，preset和plugin谁的优先级高
【360】

## 8.http

### 8.1. 从url到渲染页面题，尽可能详细。然后面试官会从每个阶段进行扩展性提问
【腾讯广告 荔枝】

[详情](https://juejin.cn/post/6844904191018680333#heading-0)

### 4.2 都有用到过哪些协议
【腾讯音乐】

1.DNS：域名解析协议

2.FTP(File Transfer Protocol)文件传输协议，它是一个标准协议，是在计算机和网络之间交换文件的最简单的方法。

3.HTTP(Hypertext Transfer Protocol )：超文本传输协议

4.HTTPS(Secure Hypertext Transfer Protocol)：安全超文本传输协议，它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作.

5.TCP（Transmission Control Protocol）： 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议  log转发：开启一个协议：tcp(三次握手和四次挥手)

### 4.3 get和post有什么区别
【360】

### 4.4 讲讲客户端存储的方式有哪些
【字节，映客直播】

特性 | Cookie | localStorage | sessionStorage | indexDB |
| -- | ------ | ------------ | --------------|------------
数据的生命期 | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器后被清除 |浏览器本地数据库永久|
存放数据大小 | 4K左右 | 一般为5MB | 一般为5MB | 没有大小限制|
与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信 | 不参与和服务器的通信|
易用性 | 需要程序员自己封装，源生的Cookie接口不友好 | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 | 非关系型数据库|



[详情>](https://www.jianshu.com/p/bb116c7a74b3)

### 4.4 如何防止脚本获取cookie
【字节】

> XSS即跨站脚本攻击，是攻击者在返回的HTML中嵌入JavaScript脚本。

防范XSS攻击,在HTTP头部上配置，`set-cookie`，有两个属性可以防止XSS攻击（获取cookie）

- **httponly** ：这个属性可`禁止JavaScript`访问Cookie，故可以保护Cookie不被嵌入的恶意代码所获取。
- **secure** ：这个属性告诉客户端浏览器仅当在`https`请求时发送Cookie
如：
```js
response.setHeader("Set-Cookie", "cookiename=httponlyTest;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly");
```
 
### 4.4 协商缓存与强缓存
【网易传媒，字节，360】

强缓存和协商缓存谁的优先级谁高？

强缓存和服务器有通讯么？

没有通讯的话有状态码么，状态码是谁返回的，缓存是存到了哪里？


[详情>](https://blog.csdn.net/goutinga/article/details/114221443)

### 4.2. http 缓存 ，内存缓存和磁盘缓存的区别，哪些文件存在这两内存

- http 缓存，即强缓存和协商缓存，[详情>](https://blog.csdn.net/goutinga/article/details/114221443)


- 内存缓存和磁盘缓存，[详情>](https://blog.csdn.net/FengNext/article/details/100172186?utm_term=%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A3%81%E7%9B%98%E5%92%8C%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-100172186&spm=3001.4430)

**解析：**

-   内存缓存会将编译解析后的文件，直接存入该进程的内存中
-   对于大文件来说，大概率是不存储在内存中的，反之优先
-   当前系统内存**使用率**高的话，文件优先存储进硬盘

在浏览器中，浏览器会在`js`和`图片`等文件解析执行后直接存入`内存缓存`中，那么当刷新页面时只需直接从`内存缓存`中读取(`from memory cache`)；而`css`文件则会存入`硬盘文件`中，所以每次渲染页面都需要从硬盘读取缓存(`from disk cache`)。

**为什么一般js和图片文件会放到内存缓存，css 放在硬盘缓存？**

样式表一般在磁盘中，不会缓存到内存中去，因为CSS样式加载一次即可渲染出网页。
但是，脚本却可能随时会执行，如果脚本在磁盘当中，在执行该脚本需要从磁盘中取到内存当中来。这样的IO开销是比较大的，有可能会导致浏览器失去响应。因此，脚本一般在内存中。

### 4.2 cookie都有哪些属性，samesite作用是什么，
【360】

cookie属性？

cookie和storage的区别是什么？

[SameSite 有哪几个值](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

### 4.1 浏览器请求头和响应头都能记起哪些，都是做什么的
【网易传媒】

**General：** 请求行

方法，状态，地址，ip

- **Request URL**:https://position.csdnimg.cn/oapi/get
- **Request Method**:GET
- **Status Code**:200
- **Remote Address**:39.96.132.69:443
- Referrer Policy:unsafe-url

**Request Headers：** 请求头

方法，路径，协议，类型，域名，来源，信息

- **:authority**:position.csdnimg.cn
- **:method**:GET `【方法】`
- **:path**:/oapi/get `【接口的地址】`
- **:scheme**: https `【协议】`
- **accept**:application/json, text/javascript, */*; q=0.01`【浏览器可以接受的媒体类型】`
- **accept-encoding**：gzip, deflate, br`【浏览器接受的编码方法】`
- **accept-language**: zh-CN,zh;q=0.9`【浏览器接受的语言】`
- **content-type**:application/json
- **origin**: https://blog.csdn.net `【域名】`
- **Host**:blog.csdn.net`【主机】`
- **referer**: https://blog.csdn.net/thc1987/article/details/86596893 `【请求的来源】`
- sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="96", "Google Chrome";v="96"
- sec-ch-ua-mobile:?0
- sec-ch-ua-platform:"Windows"
- sec-fetch-dest: empty
- sec-fetch-mode:cors
- sec-fetch-site:cross-site
- **user-agent**:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36`【浏览器信息】`

**Response Headers** 响应头

cookie，跨域，日期，类型

- access-control-allow-credentials: true
- **cookie**:''
- **access-control-allow-methods**: GET,PUT,POST,DELETE,OPTIONS 【跨域能接受的请求方法】
- **access-control-allow-origin**:https://blog.csdn.net 【设置某个站点允许跨域】
- **content-type**:application/json;charset=UTF-8 【返回的媒体类型】
- **date**:Fri, 24 Dec 2021 03:11:52 GMT 【日期】
- server:openresty
- **set-cookie**: uuid_tt_dd=10_19026958530-1640315512686-121668; Expires=Thu, 01 Jan 2025 00:00:00 GMT; Path=/; Domain=.csdn.net;

**请求头的host，origin，refer的区别是什么**

- **origin**: https://blog.csdn.net `【域名】`，带协议
- **Host**:blog.csdn.net`【主机】`，不带协议
- **referer**: https://blog.csdn.net/thc1987/article/details/86596893 `【请求的来源地址】`

### 4.2 在什么场景下会发起options请求
> 概念：options作为一次预检请求，服务器基于从预检请求头部获得的信息来判断，是否接受接下来的实际请求。

1、跨域请求，非跨域请求不会出现options请求\
2、自定义请求头\
3、请求头中的content-type是application/x-www-form-urlencoded，multipart/form-data，text/plain之外的格式

### 4.1 什么是tcp

- TCP代表`传输控制协议`，是Internet协议套件中的`基本协议`
- 是一种`网络通信协议`
- 它规定如何`建立`和`维护`两个程序交换`数据`的`连接`，如何通过Internet`发送信息`。

TCP补充了Internet协议（IP协议），它定义了用于识别Internet上系统的IP地址，主要确保不同节点之间的端到端数据传输。Internet协议提供用于传输数据的指令，同时TCP创建连接并确保将数据传递到正确的目标。这两种协议通常是协同工作的，称为TCP / IP套件。

TCPTCP与Internet协议协同工作，Internet协议定义远程节点的逻辑位置，而TCP传输并确保将数据传递到正确的目标。

**TCP的工作原理？**

TCP的工作是将消息或文件分解成更小的片段（称为数据包），在通过Internet发送。然后，这些数据包由另一个TCP层接收，然后将该数据重组为完整的文件或消息。

TCP还负责对数据流进行错误检查，以确保数据的传递; 如果发现错误，则TCP重新传输数据包。

### 4.4 一个 tcp 可以发起多少个 http请求？http2.0 有限制吗

[详情](https://blog.csdn.net/john1337/article/details/104588310)

### 4.5 tcp发送和接收包的情况，是一次性发，还是逐次发，如何排序，具体标志位是什么。

### 4.2 七层网络结构

[地址](https://blog.csdn.net/u010359398/article/details/82142449)

### 4.1 常见的HTTP状态码都有哪些
【腾讯音乐】

[详情](https://blog.csdn.net/byhage1/article/details/98208531)


### 9. 控制台的性能分析和调试

### 4.1 http1.0，1.1，2 都有哪些区别【必背】
【aptap】

#### 1. HTTP1.0

1.0的HTTP版本，是一种`无状态`（协议在交互性场景没有记忆能力，例如，记住登录状态），`无连接`（浏览器每次请求都要建立TCP连接，服务器处理完成以后立即断开TCP连接）的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。

这种`无状态`性可以借助`cookie/session`机制来做身份认证和状态记录。

>HTTP1.0存在的问题

**无法复用连接**

每次发送请求，都需要建立一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。

**队头阻塞（head of line blocking）**

由于HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

#### 2. HTTP1.1

HTTP1.1继承了HTTP1.0的简单，克服了HTTP1.0性能上的问题。

**长连接**

HTTP1.1增加`Connection`字段，通过设置`Keep-Alive`保持HTTP连接不断开。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。

如果客户端想`关闭HTTP`连接，可以在请求头中携带`Connection:false`来告知服务器`关闭`请求。

**管道化（pipelining）— 尴尬的假并行传输**

HTTP1.1支持请求管道化（pipelining）。

基于HTTP1.1的长连接，使得请求管线化成为可能。 管线化使得请求能够`并行传输`。

**例如：**

假如响应的主体是一个`html`页面，页面中包含了很多`img`，这个时候keep-alive就了很大作用。能够`并行`发送多个请求。（注意，这里的`并行`并不是真正意义上的`并行传输`）

需要注意的是：服务器必须按照`客户端`请求的`先后顺序`依次`返回`相应的结果，以保证客户端能够区分出每次请求的响应内容。

也就是说，HTTP管道化可以让我们把`先进先出队列`从客户端（请求队列）迁移到服务端（响应队列）

如果，客户端同时发了两个请求分别获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html，再发送css。
换句话来说，只有等到html响应的资源完全传输完毕后，css响应的资源才开始传输，`不允许`同时存在`两个并行`的`响应`。

可见，`HTTP1.1`还是`无法解决队头阻塞`（head of line blocking）的问题。同时“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么直接默认关闭，并且开启的条件很苛刻……而且好像实际也没有什么用处。

**真并行传输 — 浏览器优化策略**

HTTP1.1支持管道化，但是服务器也必须进行逐个响应的送回，这个是很大的一个缺陷。实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开`多个TCP`的`会话`


**缓存处理 — 强缓存、协商缓存，启发式缓存（新增）**

此外，HTTP1.1还加入了`缓存处理`（强缓存和协商缓存），新的字段如`cache-control`，支持`断点传输`，以及增加了`Host字段`（使得一个服务器能够用来创建多个Web站点）

#### 3. HTTP2.0

HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。

在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为`浏览器`限制了`同一个域名`下的`请求数量`（`Chrome` 下一般是限制`六个连接`），当页面中需要请求很多资源的时候，`队头阻塞`（Head of line blocking）会导致在达到`最大请求数量`时，`剩余`的资源需要`等待`其他资源请求完成后才能发起请求。

在 HTTP/2 中引入了`多路复用`的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

**二进制分帧**

HTTP/2 中所有加强性能的`核心`点在于此。在之前的 HTTP 版本中，我们是通过`文本`的方式`传输数据`。在 HTTP/2 中引入了新的`编码机制`，所有`传输的数据`都会被`分割`，并采用`二进制格式编码`。

**多路复用（链接共享）— 真并行传输**

`流（stream）`：已建立连接上的双向字节流。\
`消息`：与逻辑消息对应的完整的一系列数据帧。\
`帧（frame）`：帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流

所有HTTP2.0通信都在`一个TCP连接`上完成，这个连接可以承载任意流量的双向数据流。

多路复用就是在一个 TCP 连接中可以存在`多条流`。换句话说，也就是可以发送`多个请求`，对端可以通过`帧`中的`标识`知道属于哪个`请求`。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量的HTTP请求。而这个强大的功能基于`二级制分帧`的特性。

**头部压缩**

在 HTTP/1 中，我们使用`文本`的形式传输 `header`，在 header 携带 `cookie` 的情况下，可能每次都需要`重复传输`几百到几千的`字节`。

在 HTTP /2 中，使用了 `HPACK` 压缩格式对传输的 header 进行`编码`，减少了 header 的大小。并在`两端`维护了`索引表`，用于记录出现过的 `header` ，后面在传输过程中就可以传输`已经记录`过的 header 的`键名`，对端收到数据后就可以通过`键名`找到对应的`值`。

**服务器推送**

在 HTTP/2 中，服务端可以在客户端某个请求后，`主动推送`其他资源。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

#### 4.HTTP3.0

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。

因为 `HTTP/2` 使用了`多路复用`，一般来说`同一域名`下只需要使用`一个 TCP 连接`。当这个`连接`中出现了`丢包`的情况，那就会导致 HTTP/2 的表现情况反倒`不如 `HTTP/1 了。

因为在出现`丢包`的`情况下`，整个 `TCP` 都要开始`等待重传`，也就导致了`后面`的`所有数据`都`被阻塞`了。但是对于 `HTTP/1` 来说，可以`开启多个 TCP 连接`，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。

基于这个原因，`Google` 就更起炉灶搞了一个基于 `UDP 协议`的 `QUIC 协议`，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 `HTTP-over-QUIC`，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC，接下来我们就来学习关于这个协议的内容。

**Quic**

早期Quic协议，存在IETF和Google两个版本，直到它被正式命名为HTTP3.0

IETF的QUIC工作小组创造了QUIC传输协议。QUIC是一个使用UDP来替代TCP的协议。最初的时候，Google开始助力QUIC，其后QUIC更多地被叫做“HTTP/2-encrypted-over-UDP “。

社区中的人们已经使用非正式名称如iQUIC和gQUIC来指代这些不同版本的协议，以将QUIC协议与IETF和Google分开（因为它们在细节上差异很大）。通过“iQUIC”发送HTTP的协议被称为“HQ”（HTTP-over-QUIC）很长一段时间。

2018年11月7日，Litespeed的Dmitri宣布他们和Facebook已经成功地完成了两个HTTP/3实现之间的第一次互操作。Mike Bihop在该主题的HTTPBIS会话中的后续介绍可以在这里看到。会议结束时达成共识称新名称是HTTP/3！


之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。

**多路复用**

虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC `原生就实现`了这个功能，并且传输的`单个数据流`可以保证`有序交付`且`不会影响其他的数据流`，这样的技术就解决了之前 TCP 存在的问题。

并且 QUIC `在移动端`的表现也会比 TCP 好。因为 TCP 是基于 `IP` 和`端口`去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上


#### 总结

**HTTP 1.0**

- 无状态，无连接
- 短连接：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能
- 无host头域，也就是http请求头里的host
- 不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象

**HTTP 1.1**

- 长连接，流水线，使用connection:keep-alive使用长连接
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段，支持断点传输等
- 由于长连接会给服务器造成压力

**HTTP 2.0**

- 二进制分帧
- 头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小
- 多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求
- 服务器推送（Sever push）

**HTTP 3.0**

- 基于google的QUIC协议，而quic协议是使用udp实现的
- 减少了tcp三次握手时间，以及tls握手时间
- 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题
- 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
- 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
- 更合适的流量控制
- 基于UDP实现
- 0RTT建连
- 基于UDP的多路复用
- 加密认证的报文
- 向前纠错机制

[详情1](https://blog.csdn.net/qq_42872073/article/details/112836905)

[详情2](https://blog.csdn.net/ailunlee/article/details/97831912)


### 4.2 http和tcp的队头阻塞

**tcp队头阻塞**

在出现`丢包`的`情况下`，整个 `TCP` 都要开始`等待重传`，也就导致了`后面`的`所有数据`都`被阻塞`了

**http 1.0 队头阻塞**

由于HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

**http 1.1 管道化阻塞**

HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。

**如何解决HTTP队头阻塞**

对于HTTP1.1中`管道化`导致的`请求/响应`级别的队头阻塞，可以使用`HTTP2`解决。

HTTP2不使用管道化的方式，而是引入了`帧、消息和数据流`等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。

当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能应该丢包重传出现TCP队头阻塞。

**如何解决TCP队头阻塞**

TCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议，使用http3.0。

http3.0使用的是google推出的quic协议，避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。

### 4.1 http2问答

【腾讯】
http2 都有哪些应用，多路复用和 1.1 版本 keep-alive 有什么区别和联系，如果 http1.1 服务端需要按顺序处理请求，那为什么有的时候在一个页面里看图片，有时下面的图片会先出来，http pipeline 有了解吗，http 流传输有了解吗


### 4.2 TCP 三次握手
【aptap】
[link](https://juejin.cn/post/6844904191018680333#heading-6)


### 4.2 一个 tcp 可以发起多少个 http请求？http2.0 有限制吗

[详情](https://blog.csdn.net/john1337/article/details/104588310)

### 4.3  https，为什么 https 可以防中间人攻击

【美团,金山】

**什么是https**

HTTPS，是以`安全`为`目标`的`HTTP通道`，简单讲是HTTP的安全版。即HTTP下加入`SSL`层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL

**Https的作用**

-   **内容加密** 建立一个信息安全通道，来保证数据传输的安全；
-   **身份认证** 确认网站的真实性
-   **数据完整性** 防止内容被第三方冒充或者篡改

**HTTPS和HTTP的区别**

- https协议需要到`CA`申请证书，一般免费证书很少，需要`交费`。
- http是`超文本传输协议`，信息是`明文`传输；https 则是具有`安全性`的`ssl加密传输协议`。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。
- http的连接很简单，是`无状态`的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议`安全`。

[详情](https://blog.csdn.net/wx_962464/article/details/51043069)

**什么是中间人攻击**

[详情》](https://netsecurity.51cto.com/art/202007/621637.htm)

指`攻击者`与通讯的`两端`分别创建`独立的联系`，并交换其所收到的数据，使通讯的两端认为他们正在通过一个`私密的连接`与对方 `直接对话`，但事实上整个会话都被攻击者`完全控制`。
![image.png](https://img-blog.csdnimg.cn/img_convert/292e23dcf2a6d6d43c1f60f3c13cf1da.png)
### 13.  HTTPS一定是安全的吗？

不一定。

现在我们是使用ca公钥对ca机构颁发的ca数字证书进行验证，基于对于CA的信任机制。

所以这个信任机制有问题的话，那就可能不安全

第一个方面，
那么ca机构是否存在是假的吗？
会存在，但是一般不会发生，因为公司一般去申请ca证书的时候，都会选择正规的CA机构。几乎不可能存在去假的CA机构进行验证。
另外，虽然正规CA的公钥公开，即使这中间人解开了CA数字证书，也没法改变数据之后进行私钥加密，因为“中间人攻击”的中间人不会得到正规CA的私钥。
只有公司去了假了CA机构申请，才会有私钥。

第二个方面
数字证书不一定用CA机构颁发的，数字证书是可以自定义的。一般这种情况，需要手动安装数字证书，获取这个证书一般是去官网下载。
那么获取数字证书的时候就有可能出问题。
有可能下载数字证书的时候，被劫持，替换为中间人的数字证书。这样，以后传输数据的时候，就会发送中间人攻击了。


### 12. TLS握手过程

 TLS 握手是启动 HTTPS 通信的过程，类似于 TCP 建立连接时的三次握手。 在 TLS 握手的过程中，通信双方交换消息以相互验证，相互确认，并确立它们所要使用的加密算法以及会话密钥 (用于对称加密的密钥)。可以说，TLS 握手是 HTTPS 通信的基础部分。

- 商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3等等)；
- 确定双方所要使用的密码组合；
- 客户端通过服务器的公钥和数字证书 (上篇文章已有介绍)上的数字签名验证服务端的身份；
- 生成会话密钥，该密钥将用于握手结束后的对称加密。

TLS的握手过程？哪个环节用到了私钥？

[详情](https://segmentfault.com/a/1190000021559557)

### 44. HTTP缓存

【美团，映客直播】

强缓存和弱缓存[详情>](https://blog.csdn.net/goutinga/article/details/114221443)

### 4.5 chrome 浏览器最多同时加载多少个资源，那如果想同时加载更多资源应该怎么办

6个

**为什么浏览器会限制并行请求数量？**

- 浏览器发出网络请求需要新开线程，而且可以发出请求的端口数量有限，从开销角度考虑不可能无限发出并发请求；
- 此外如果浏览器不作限制，大量的请求同时发至服务器，也可能超过服务器的处理并发请求的数量阈值（针对单个 IP），从而导致请求失败。

**解决方法：**

1. 多个请求使用不能的域名，将静态资源放置于 CDN。

2. 使用WebSocket协议，主流的浏览器对WebSocket连接并发数量的限制都远超6个。

3. 使用HTTP/2.0，理论上HTTP/2.0协议支持在同一个TCP连接上发送无限个HTTP请求，且这些请求的生命期可以重叠。（通过流来传递）

4. 使用懒加载，一些图片可以等到出现在视图区才加载

[参考](https://www.zhihu.com/question/20474326/answer/15696641)

### 4.5 离线存储
【网易传媒】

### 4.5 Websocket 介绍一下，它和 http 有什么关系
【金山】

我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？

答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。

举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。（http3.0好像支持了）

WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。

它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

其他特点包括：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

[link](https://www.ruanyifeng.com/blog/2017/05/websocket.html)

### 4.8 你们的 RPC 用的哪个框架，grpc 和 thrift 的区别有了解么，protobuf 有了解吗
【网易灵犀】

### 4.8 一个页面的性能指标都有哪些，你是如何做监控的，如何监控 node 服务的性能监控
【网易灵犀】

### 4.9 localstorage的会不会出现不同项目的key覆盖别人的key的问题，如何解决
【百度】

可能会出现，如果项目部署的地址的同源的话

建一个对象，将存储的本地数据放在对象里面属性里面，属性的key为项目名，value就是我们要存储的值。通过项目名来隔离。

### 4.10 浏览器发请求和node发请求都有什么区别，浏览器都为发请求做了哪些默认行为
【大疆】

### 4.11 如何理解线程和进程
【大疆】

`进程`就好比工厂的车间，它代表CPU所能处理的单个任务。 `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法来实现同时运行多个`进程`。

浏览器没打开一个标签页就是一个进程

-   `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
-   `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
-   不同`进程`之间也可以通信，不过代价较大
-   `单线程`与`多线程`，都是指在一个`进程`内的单和多

[详情](https://juejin.cn/post/6844903919789801486)
### 4.13 浏览器进程模型有了解吗
【腾讯音乐】

### 4.12  浏览器都有过哪些了解，内核都有哪些，chrome浏览器开启一个页签时开启了多少个进程，对应开启了哪些线程
【360】


### 4.13 讲讲状态码301/302/307的区别；
【字节】

 [详情>](https://www.cnblogs.com/goloving/p/14087235.html)
 
### 10.1 浏览器跨域的方式有哪些？如何解决前端跨域；
【网易传媒，字节，虾皮】

协议，域名，端口不同即跨域

`http://ip:port` 与指向该 ip:port 的域名是同域吗？

一个ip可以对应多个域名，但域名和对应的ip是不同域的

[详情>](https://www.imooc.com/article/291931)

### 10. 浏览器刷新频率？

一般为：60赫兹

### 8. CDN的原理
**1. 什么是CDN？**

CDN是构建在网络之上的`内容分发网络`，依靠部署在各地的`边缘服务器`，使用户`就近获取`所需内容，降低网络拥塞，提高用户访问`响应速度`和`命中率`。

CDN的关键技术主要有内容存储和分发技术。

**2. 基本原理**

CDN的基本原理是广泛采用各种`缓存服务器`，将这些缓存服务器分布到用户`访问相对集中`的`地区`或`网络`中，在用户访问网站时，利用`全局负载`技术将用户的访问`指向距离最近`的缓存服务器上，由缓存服务器`直接响应`用户请求。

**3.基本思路**

基本思路是尽可能`避开`互联网上有可能`影响数据传输速度`和`稳定性`的`瓶颈`和`环节`，使内容传输的更快、更稳定。

通过在`网络各处`放置`节点服务器`所构成的在`现有的`互联网基础之上的一层`智能虚拟网络`，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及`到用户的距离`和`响应时间`等综合信息将用户的请求`重新导向`离用户`最近`的`服务节点`上。

其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

**4 . 服务模式**

内容分发网络(CDN)是一种`新型网络构建方式`，它是为能在`传统的IP网`发布`宽带丰富媒体`而特别优化的`网络覆盖层`；而从广义的角度，CDN代表了一种基于`质量`与`秩序`的网络服务模式。

简单地说，内容分发网络(CDN)是一个经`策略性部署`的`整体系统`，包括`分布式存储`、`负载均衡`、`网络请求的重定向`和`内容管理`4个要件，而**内容管理**和**全局的网络流量管理**(Traffic Management)是CDN的`核心所在`。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。

总的来说，内容服务基于缓存服务器，也称作代理缓存(Surrogate)，它位于网络的边缘，距用户仅有"一跳"(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。


**5.关键技术**

**（1）内容发布**：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；

**（2）内容路由**：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应；

**（3）内容交换**：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；

**（4）性能管理**：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。

**6 . 主要特点**

**1、本地Cache加速** 提高了企业站点(尤其含有大量图片和静态页面站点)的访问速度，并大大提高以上性质站点的稳定性

**2、镜像服务** 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。

**3、远程加速** 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度

**4、带宽优化** 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。

**5、集群抗攻击** 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。

### 8.1 同源两个标签页的通讯方式
[详情》](https://blog.csdn.net/ciel_2/article/details/111998536)

